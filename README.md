<body>

  <h1>One-Click-RTL-to-GDSII-Automation-Framework-for-Single-Clock-Designs</h1>

  <p class="muted">
    This project implements a fully automated RTL-to-GDSII flow using Bash + Tcl. Given a single Verilog design (source.v), the framework automatically performs synthesis, padframe generation, netlist modification, floorplanning, powerplanning, placement, CTS, routing, and GDSII generation.
  </p>

  <h2>1. Overview</h2>
  <p>The framework automates the following steps when given one top-level Verilog file named <code>source.v</code> (module name expected to be <code>source</code>):</p>
  <ul>
    <li><strong>Synthesis</strong> - automatic Genus TCL script generation and run (mapped netlist, SDC, reports).</li>
    <li><strong>Padframe generation</strong> - detect input and output ports, compute pads-per-side and create <code>padframe.io</code>.</li>
    <li><strong>Netlist modification</strong> - insert pad instances into the synthesized netlist (<code>pc3d01</code> for IO, <code>pc3c01</code> for clocks) before <code>endmodule</code>.</li>
    <li><strong>Floorplan sizing</strong> - compute core width from pads-per-side and inject into Innovus TCL.</li>
    <li><strong>Physical design automation</strong> - run Innovus steps: Floorplan → Powerplan → Placement → CTS → Routing → StreamOut (GDSII).</li>
  </ul>

  <h2>2. Flow Description</h2>

  <h3>Design ingestion</h3>
  <p>The script expects a single Verilog file called <code>source.v</code> with the top module named <code>source</code>. The flow currently targets single-clock designs.</p>

  <h3>Synthesis stage</h3>
  <p>A Genus TCL script is created automatically and executed. Genus produces:</p>
  <ul>
    <li>Technology-mapped netlist (written as <code>source_netlist.v</code>).</li>
    <li>SDC constraints (<code>source.sdc</code>).</li>
    <li>Standard synthesis reports (timing, area, power, clock).</li>
  </ul>

  <h3>Padframe generation</h3>
  <p>The padframe generator inspects the synthesized netlist, enumerates ports, expands buses into individual pads, rounds pad count to a multiple of 4, and distributes pads evenly on the four sides. The output file is <code>padframe.io</code>.</p>

  <h3>Netlist modification</h3>
  <p>The netlist modifier reads the synth netlist and inserts pad instantiations automatically. Naming conventions are consistent with the padframe so Innovus can load the IO file without manual edits. Result: <code>source_netlist_modified.v</code>.</p>

  <h3>Backend (Innovus) flow</h3>
  <p>The Innovus TCL script - generated by the framework and expanded with the computed core width and PDK paths — performs:</p>
  <ol>
    <li>Floorplan</li>
    <li>Powerplan</li>
    <li>Placement</li>
    <li>Clock Tree Synthesis (CTS)</li>
    <li>Routing</li>
    <li>Stream out final GDSII</li>
  </ol>
  <p class="muted">Each phase saves designs (.enc) and reports.</p>

  <div class="section">
  <h2>Tested Design Example (8-bit ALU, Single Clock)</h2>

  <p>
    This framework was fully tested on a single-clock 8-bit ALU design (<code>source.v</code>).
    The design was synthesized, padframe generated, netlist modified, and taken through the complete Innovus backend flow
    (<strong>floorplan → Powerplan → Placement → CTS → Routing → GDSII</strong>) without any manual edits.
  </p>

  <p>
    The flow executed successfully and produced consistent results at every stage.
    All generated reports, intermediate files, and layout snapshots have been uploaded in the repository under:<code>tested_on_ALU/</code>
  </p>

  <p>Below are the results obtained for each phase of the flow:</p>

  <li>Synthesis (Genus)</li>
  <img height="400" alt="synthesis" src="https://github.com/user-attachments/assets/b3f7f9d2-e7a2-48f5-b28c-debaa89b1a33" />

  <li>Floorplan</li>
  <img height="400" alt="fp" src="https://github.com/user-attachments/assets/a1405987-cb64-451b-a152-9bf51b1417b9" />


  <li>Power Planning</li>
 <img height="400" alt="pp" src="https://github.com/user-attachments/assets/50f571d9-6ddb-489b-986e-495882a33080" />


  <li>Placement</li>
<img height="400" alt="pl" src="https://github.com/user-attachments/assets/786adb8c-e605-46ea-aa4d-37210f322f24" />


  <li>Clock Tree Synthesis (CTS)</li>
<img height="400" alt="cts" src="https://github.com/user-attachments/assets/58eb824b-d14b-41cf-98b2-8a1be41aa9a7" />


  <li>8. Routing</li>
<img height="400" alt="rou" src="https://github.com/user-attachments/assets/acc144e0-7692-48d5-a391-66934019db00" />

  <p>
    <strong>Summary:</strong> The 8-bit ALU test confirms that the automation framework works end-to-end without user intervention.
    All intermediate and final results are provided in the repository for reference.
  </p>
</div>


  <h2>4. Tools Used</h2>
  <ul>
    <li>Cadence Genus</li>
    <li>Cadence Innovus</li>
  </ul>

  <h2>5. Repository structure</h2>
  <pre class="files">
  main_script        → This folder contains main script required to run the complete RTL-to-GDSII flow.
  tested_on_ALU      → This folder contains the output of the full flow tested on an 8-bit ALU (single clock).</pre>

  <h2>6. Requirements</h2>
  <p class="muted">This framework targets all VLSI lab PCs (present in our college) where Cadence tools and the SCL PDK are available.</p>
  <ul>
    <li>Cadence tools (Genus, Innovus) installed on the system</li>
    <li>SCL PDK placed under the default lab path: <code>/home/vlsiXX/Downloads/scl_pdk</code>.</li>
    <li>If PDK or Cadence source path is different, the script supports two overrides: PDK_BASE and CADENCE_CSH. These variables can be changed at the top of the script.</li>
    <li>Single Verilog file named <code>source.v</code> with top module <code>source</code>. Single-clock designs are currently supported.</li>
  </ul>

  <div class="callout">
    <strong>Portability note:</strong> the script auto-detects the lab PC number (e.g. <code>/home/vlsi12</code>) and adjusts PDK/Cadence paths automatically. If your PDK or Cadence source script is installed elsewhere, update <code>PDK_BASE</code> and <code>CADENCE_CSH</code> in the top of <code>./rtl_to_gdsii_automation.sh</code>.
  </div>
  <br>
  <footer>
    <p class="muted">
      <strong>To get started:</strong> place your <code>source.v</code> in the project root and run <code>./rtl_to_gdsii_automation.sh</code> from the same directory.
    </p>
  </footer>

</body>
